{"library_version": "6.6.1", "change_type": "Bug Fixes", "change_id": "LUCENE-7869", "change_description": ": Changed MemoryIndex to sort 1d points. In case of 1d points, the PointInSetQuery.MergePointVisitor expects\nthat these points are visited in ascending order. The memory index doesn't do this and this can result in document\nwith multiple points that should match to not match.", "change_title": "MemoryIndex should sort 1d points", "detail_type": "Bug", "detail_affect_versions": "None", "detail_fix_versions": "6.6.1,6.7,7.0", "detail_description": "In case of 1d points, the PointInSetQuery.MergePointVisitor expects that these points are visited in ascending order. The memory index doesn't do this and this can result in document with multiple points that should match to not match.", "patch_link": "https://issues.apache.org/jira/secure/attachment/12871870/LUCENE_7869.patch", "patch_content": "none"}
{"library_version": "6.6.1", "change_type": "Bug Fixes", "change_id": "LUCENE-7878", "change_description": ": Fix query builder to keep the SHOULD clause that wraps multi-word synonyms.", "change_title": "QueryParser AND default operator and MultiWords synonyms failed if keywords exactly matches a synonym", "detail_type": "Bug", "detail_affect_versions": "6.5.1,6.6,7.0", "detail_fix_versions": "6.6.1,6.7,7.0", "detail_description": "This issue is about using the QueryParser with MultiWordsSynonyms. To reproduce the bug: In short, the part of the query which handle the synonym lookup should keep a \"OR\" relation between the synonyms, but it is translated as a \"AND\". If I parse: \"guinea pig\" which is a synonym of \"cavy\": Using default OR, I get something correct:     \"(+guinea +pig) cavy\" Note: I should probably better have ((+guinea +pic) cavy) Using AND as default operator, I get something wrong:     +(+guinea +pig) +cavy I was expected:     +((+guinea +pig) cavy) The relation between \"guinea pig\" and \"cavy\" is now a AND. It should be still a OR because it is a synonym clause. To help understanding. If now I parse \"guinea pig world\" And I get the expected result:     +((+guinea +pig) cavy) +world The relation between \"guinea pig\" and \"cavy\" is a OR as expected (it is a synonym), and the relation with \"world\" is AND as expected by the default operator. Here is the additional unit test for, I hope it is pretty self-explanatory: org.apache.lucene.queryparser.classic.TestQueryParser", "patch_link": "https://issues.apache.org/jira/secure/attachment/12873003/LUCENE-7878.patch", "patch_content": "none"}
