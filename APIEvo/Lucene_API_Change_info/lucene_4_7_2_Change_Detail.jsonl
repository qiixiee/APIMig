{"library_version": "4.7.2", "change_type": "Bug Fixes", "change_id": "LUCENE-5574", "change_description": ": Closing a near-real-time reader no longer attempts to\ndelete unreferenced files if the original writer has been closed;\nthis could cause index corruption in certain cases where index files\nwere directly changed (deleted, overwritten, etc.) in the index\ndirectory outside of Lucene.", "change_title": "NRT Reader close can wipe index it doesn't own", "detail_type": "Bug", "detail_affect_versions": "4.7.1,4.8,6.0", "detail_fix_versions": "4.7.2,4.8,6.0", "detail_description": "Today NRT Readers try to clean up unused files via their IW reference when they are closed. Yet, if the index writer is already closed another index could have been created on the same directory which can create the same files as the IW before. For the NRT Reader those files are not referenced and it will simply wipe them away. If you use this in a replication scenario where directories are reused this can simply wipe your index away or in combination with the FSync issue LUCENE-5570 create 0-byte files. I have a test that reproduces this issue", "patch_link": "https://issues.apache.org/jira/secure/attachment/12638697/LUCENE-5574.patch", "patch_content": "none"}
{"library_version": "4.7.2", "change_type": "Bug Fixes", "change_id": "LUCENE-5570", "change_description": ": Don't let FSDirectory.sync() create new zero-byte files, instead throw\nexception if a file is missing.", "change_title": "FSDirectory's fsync() is lenient", "detail_type": "Bug", "detail_affect_versions": "None", "detail_fix_versions": "4.7.2,4.8,6.0", "detail_description": "This method has a lot of problems: 1. it tracks 'stale files' as it writes (this seems pointless), and only actually fsyncs the intersection of that 'stale files' and the filenames passed as argument to sync(). So any bogus names passed to sync() are just silently ignored 2. if \"something bad happens\" (e.g. two indexwriters/dirs on the same path, or some other shenanigans), and the file is actually in stale files, but was say actually deleted on the filesystem, the underlying fsync() call will create a new 0-byte file and fsync that. In my opinion we should do none of this. we should throw exceptions when this stuff is wrong.", "patch_link": "https://issues.apache.org/jira/secure/attachment/12638742/LUCENE-5570_java6.patch", "patch_content": "none"}
