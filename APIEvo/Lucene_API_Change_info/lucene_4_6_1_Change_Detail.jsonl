{"library_version": "4.6.1", "change_type": "Bug fixes", "change_id": "LUCENE-5373", "change_description": ": Memory usage of\n[Lucene40/Lucene42/Memory/Direct]DocValuesFormat was over-estimated.", "change_title": "Lucene42DocValuesProducer.ramBytesUsed is over-estimated", "detail_type": "Bug", "detail_affect_versions": "None", "detail_fix_versions": "4.6.1", "detail_description": "Lucene42DocValuesProducer.ramBytesUsed uses RamUsageEstimator.sizeOf(this) to return an estimation of the memory usage. One of the issues (there might be other ones) is that this class has a reference to an IndexInput that might link to other data-structures that we wouldn't want to take into account. For example, index inputs of a RAMDirectory all point to the directory itself, so Lucene42DocValuesProducer.ramBytesUsed would return the amount of memory used by the whole directory.", "patch_link": "https://issues.apache.org/jira/secure/attachment/12619792/LUCENE-5373.patch", "patch_content": "none"}
{"library_version": "4.6.1", "change_type": "Bug fixes", "change_id": "LUCENE-5361", "change_description": ": Fixed handling of query boosts in FastVectorHighlighter.", "change_title": "FVH throws away some boosts", "detail_type": "Bug", "detail_affect_versions": "None", "detail_fix_versions": "4.6.1", "detail_description": "The FVH's FieldQuery throws away some boosts when flattening queries, including DisjunctionMaxQuery and BooleanQuery queries.   Fragments generated against queries containing boosted boolean queries don't end up sorted correctly.", "patch_link": "https://issues.apache.org/jira/secure/attachment/12617419/LUCENE-5361.patch", "patch_content": "none"}
{"library_version": "4.6.1", "change_type": "Bug fixes", "change_id": "LUCENE-5374", "change_description": ": IndexWriter processes internal events after the it\nclosed itself internally. This rare condition can happen if an\nIndexWriter has internal changes that were not fully applied yet\nlike when index / flush requests happen concurrently to the close or\nrollback call.", "change_title": "Call processEvents before IndexWriter is closed", "detail_type": "Bug", "detail_affect_versions": "4.6", "detail_fix_versions": "4.6.1,4.7,6.0", "detail_description": "We saw failures on jenkins that complain about processing events in the IW while the IW is already closed: we need to process the events before we enter the finally block in IW#closeInternal", "patch_link": "https://issues.apache.org/jira/secure/attachment/12619619/LUCENE-5374.patch", "patch_content": "none"}
{"library_version": "4.6.1", "change_type": "Bug fixes", "change_id": "LUCENE-5394", "change_description": ": Fix TokenSources.getTokenStream to return payloads if\nthey were indexed with the term vectors.", "change_title": "TokenSources.getTokenStream doesn't return payloads", "detail_type": "Bug", "detail_affect_versions": "None", "detail_fix_versions": "4.6.1,6.0", "detail_description": "In LUCENE-1888, we enabled indexing payloads into term vectors, but the highlighter APIs that \"reconstruct\" a token stream from term vectors fail to plumb through the payloads if they were indexed.", "patch_link": "https://issues.apache.org/jira/secure/attachment/12622498/LUCENE-5394.patch", "patch_content": "none"}
{"library_version": "4.6.1", "change_type": "Bug fixes", "change_id": "LUCENE-5344", "change_description": ": Flexible StandardQueryParser behaves differently than\nClassicQueryParser.", "change_title": "Flexible StandardQueryParser behaves differently than ClassicQueryParser", "detail_type": "Bug", "detail_affect_versions": "4.5", "detail_fix_versions": "4.6.1,4.7,6.0", "detail_description": "AnalyzerQueryNodeProcessor creates a BooleanQueryNode instead of a MultiPhraseQueryNode for some circumstances. Classic query parser output: +content:a +content:320 (correct) Flexible query parser output: content:a content:320 (wrong) The used analyzer:", "patch_link": "https://issues.apache.org/jira/secure/attachment/12622790/LUCENE-5344_adrianocrestani_2014-01-14_branch_4x.patch", "patch_content": "none"}
{"library_version": "4.6.1", "change_type": "Bug fixes", "change_id": "LUCENE-5375", "change_description": ": ToChildBlockJoinQuery works harder to detect mis-use,\nwhen the parent query incorrectly returns child documents, and throw\na clear exception saying so.", "change_title": "ToChildBlockJoinQuery becomes crazy on wrong subquery", "detail_type": "Bug", "detail_affect_versions": "4.6", "detail_fix_versions": "4.6.1,6.0", "detail_description": "If user supplies wrong subquery to ToParentBlockJoinQuery it reasonably throws IllegalStateException. (http://lucene.apache.org/core/4_0_0/join/org/apache/lucene/search/join/ToParentBlockJoinQuery.html 'The child documents must be orthogonal to the parent documents: the wrapped child query must never return a parent document.'). However ToChildBlockJoinQuery just goes crazy silently. I want to provide simple patch for ToChildBlockJoinQuery with if-throw clause and test. See http://mail-archives.apache.org/mod_mbox/lucene-solr-user/201311.mbox/%3CF415CE3A-EBE5-4D15-ADF1-C5EAD32A1EB2@sheffield.ac.uk%3E", "patch_link": "https://issues.apache.org/jira/secure/attachment/12778741/LUCENE-5375.patch", "patch_content": "none"}
{"library_version": "4.6.1", "change_type": "Bug fixes", "change_id": "LUCENE-5401", "change_description": ": Field.StringTokenStream#end() calls super.end() now,\npreventing wrong term positions for fields that use\nStringTokenStream.", "change_title": "Field.StringTokenStream#end() does not call super.end()", "detail_type": "Bug", "detail_affect_versions": "4.6", "detail_fix_versions": "4.6.1,4.7,6.0", "detail_description": "Field.StringTokenStream#end() currently does not call super.end(). This prevents resetting the PositionIncrementAttribute to 0 in end(), which can lead to wrong positions in the index under certain conditions. I added a test to TestDocument which indexes two Fields with the same name, String values, indexed=true, tokenized=false and IndexOptions.DOCS_AND_FREQS_AND_POSITIONS. Without the fix the test fails. The first token gets the correct position 0, but the second token gets position 2 instead of 1. The reason is that in DocInverterPerField line 176 (which is just after the call to end()) we increment the position a second time, because end() didn't reset the increment to 0. All tests pass with the fix.", "patch_link": "https://issues.apache.org/jira/secure/attachment/12623284/lucene-5401.patch", "patch_content": "none"}
{"library_version": "4.6.1", "change_type": "Bug fixes", "change_id": "LUCENE-5377", "change_description": ": IndexWriter.addIndexes(Directory[]) would cause corruption\non Lucene 4.6 if any index segments were Lucene 4.0-4.5.", "change_title": "IW.addIndexes(Dir[]) causes silent index corruption", "detail_type": "Bug", "detail_affect_versions": "4.6", "detail_fix_versions": "4.6.1,4.7,6.0", "detail_description": "my old facet index create by Lucene version=4.2 use indexChecker ok. now I upgrade to Lucene 4.6 and put some new records to index. then reopen index, some files in indexdir missing.... no .si files. I debug into it,  new version format of segments.gen(segments_N) record bad segments info.", "patch_link": "https://issues.apache.org/jira/secure/attachment/12624356/LUCENE-5377.patch", "patch_content": "none"}
